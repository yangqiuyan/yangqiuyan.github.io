<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习1]]></title>
    <url>%2F2020%2F05%2F07%2F%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[1.Handler 机制Handler 机制 创建 Handler，Handler获取当前线程的 looper和 queue，queue 将 message 加入合适的位置，looper 循环从 queue中取出 message，分发 message。 Looper.prepare()创建一个 Looper 对象，放入 sThreadLocal 变量中 Looper创建 MessageQueue 消息队列，并让当前的 looper 持有当前线程 Handler 在创建的时候，获取当前线程的 looper（sThreadLocal.get()），通过 looper持有queue 队列 Looper.loop() 循环通过 queue.next()获取 message 对象，并通过dispatchMessage分发 msg，若 queue 中没有 msg，则next()阻塞，挂起当前线程，若 queue 返回 null，结束死循环。 queue.next（）方法中也有一个死循环，若有可以处理的 msg，返回 msg 给 looper 处理，若没有可以处理的 msg，执行 IdlHandler，否则就一直在循环，若 looper 结束，则返回 null，结束死循环。 1.1 如果消息队列为空如果消息队列为null，抛出RuntimeException 异常，如果是队列为空,queue.next()取出 message 为空，则挂起当前线程 1.2 postDelay() 30分钟，调整系统时间会怎样postDelay()延时，使用SystemClock.uptimeMillis() + delayMillis 实现，SystemClock.uptimeMillis()获取从手机开机到现在的毫秒时间（不含深度睡眠时间），所以修改系统时间不会影响 postDelay() 30分钟后的操作 1.3ThreadLocal线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本 1.4 IdleHandler在当前线程消息队列空闲时做些事情，queueIdle返回 true 说明执行后，在下次进入空闲状态后继续执行，返回 false 只执行一次，执行完后删除 第三方库是否使用不详，LeakCanary，Glide用过？ 2.JAVA 内存模型在 Java 内存模型中，我们统一用工作内存（working memory）来当作 CPU 中寄存器或高速缓存的抽象。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有工作内存（类比 CPU 中的寄存器或者高速缓存），本地工作内存中存储了该线程读/写共享变量的副本。 3.sync/volatile当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。（保证多线程操作的可见性，但是不能保证变量的原子性） synchronized能保证变量的原子性、可见性和有序性 在单例模式下 123456789101112private static volatile LoginLogic instance; // 保证在多线程执行初始化的时候，已经初始化后的变量对其他线程是可见的public static LoginLogic getInstance() &#123; if (instance == null) &#123; synchronized (LoginLogic.class) &#123; // 多个线程只有一个线程执行下面的初始化代码段 if (instance == null) &#123; // 初始化后volatile保证可见性确保其他线程在这个阶段变量!=null instance = new LoginLogic(); &#125; &#125; &#125; return instance; &#125; System.currentTimeMillis()是一个标准的“墙”时钟(时间和日期)，表示从纪元到现在的毫秒数。该墙时钟能够被用户或电话网络(见setCurrentTimeMillis(long))设置，所以该时间可能会向前或向后不可预知地跳越。该时钟应该仅仅被使用在当现实世界的对应的日期和时间是重要的情况，例如一个日历或闹钟应用程序。而间隔时间和经过时间应该使用不同的时钟。如果你使用System.currentTimeMillis()，可以考虑监听ACTION为ACTION_TIME_TICK、ACTION_TIME_CHANGED、ACTION_TIMEZONE_CHANGED 的广播去监听时间变化。 uptimeMillis()表示自系统启动时开始计数，以毫秒为单位。返回的是从系统启动到现在这个过程中的处于非休眠期的时间。当系统进入深度睡眠时(CPU关闭，设备变黑，等待外部输入装置)该时钟会停止。但是该时钟不会被时钟调整，闲置或其他节能机所影响。这是大多数间隔时间的基本点，例如Thread.sleep(millls)、Object.wait(millis)和System.nanoTime()。该时钟被保证是单调的，适用于检测不包含休眠的间隔时间的情况。大多数的方法接受一个时间戳的值除了uptimeMillis()时钟。 elapsedRealtime() and elapsedRealtimeNanos() 返回系统启动到现在的时间，包含设备深度休眠的时间。该时钟被保证是单调的，即使CPU在省电模式下，该时间也会继续计时。该时钟可以被使用在当测量时间间隔可能跨越系统睡眠的时间段。 作者：活这么大就没饱过链接：https://www.jianshu.com/p/1d5ef19f1faa来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout那些坑]]></title>
    <url>%2F2019%2F12%2F18%2FTabLayout%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近的项目中，要在一个模块当中，增加一个tab分类，每个分类展示不同的数据，理所当然的想到了用TabLayout+ViewPager+Fragment来实现，因此也遇到了一些TabLayout的坑，记录一下这些血泪史。。。 1. TabLayout最小宽度因为分类一共有6个，屏幕宽度不够放下所有的tab，只能设置成滚动tab，每个tab设置左右边距13dp，很简单，TabLayout都有对应的属性可以设置。 1234567&lt;android.support.design.widget.TabLayout // 其他属性 // 设置padding app:tabPaddingStart="13dp" app:tabPaddingEnd="13dp" app:tabMode="scrollable" /&gt; 结果发现每个tab的宽度很大，边距比13dp还大，这肯定是逃不过UI小姐姐的眼睛的，小姐姐要求边距一定只能13dp。行，那就解决问题，换了几个padding值，感觉还是那么大，好像没什么变化，只好从TabLayout的源码入手。源码看着看着，发现在初始化的时候，有一个属性 1this.scrollableTabMinWidth = res.getDimensionPixelSize(dimen.design_tab_scrollable_min_width); 而这个design_tab_scrollable_min_width有72dp，所以就算文字只有1个字，也要保持72dp的宽度。但是这个属性好像不能修改，接着看源码。 1234567private int getTabMinWidth() &#123; if (this.requestedTabMinWidth != -1) &#123; return this.requestedTabMinWidth; &#125; else &#123; return this.mode == 0 ? this.scrollableTabMinWidth : 0; &#125;&#125; 看这个获取minWidth，在我们没有设置minWidth的时候，会判断模式是不是滚动模式，如果是，就取scrollableTabMinWidth，这就好办了，只要我们设置一个minWidth，就可以自己设置padding值了。 12345678&lt;android.support.design.widget.TabLayout // 其他属性 // 设置padding app:tabMinWidth="0dp" // 设置minWidth为0 app:tabPaddingStart="13dp" app:tabPaddingEnd="13dp" app:tabMode="scrollable" /&gt; TabLayout的UI问题算是搞定了。 2. TabLayout抖动问题简单描述一下抖动问题，就是当TabLayout的tab数量超出屏幕并且可以滚动的时候，手动滚动TabLayout，选择一个在屏幕外的tab点击，TabLayout会先滚动回原来的tab，再滚动到点击的tab位置，出现类似抖动的现象，具体可以看使用系统TabLayout的app快来修Bug。 按照上面那篇的文章进行更改，结果发现用反射找不到mPageChangeListener，不知道是不是Android9开始限制反射的原因，导致我的Android10手机无法用反射更改这个listener，那只能自己再找其他方法了。 根据上面那个作者的思路，我们看pageChangeListener在哪里使用。 123456789101112131415161718192021// TabLayout源码 private void setupWithViewPager(@Nullable ViewPager viewPager, boolean autoRefresh, boolean implicitSetup) &#123; if (this.viewPager != null) &#123; if (this.pageChangeListener != null) &#123; this.viewPager.removeOnPageChangeListener(this.pageChangeListener); &#125; // ... &#125; // ... if (viewPager != null) &#123; this.viewPager = viewPager; if (this.pageChangeListener == null) &#123; this.pageChangeListener = new TabLayout.TabLayoutOnPageChangeListener(this); &#125; this.pageChangeListener.reset(); viewPager.addOnPageChangeListener(this.pageChangeListener); // ... &#125; // ... &#125; 可以看到，在TabLayout关联viewpager的时候，viewpager先移除已经存在的pageChangeListener，后面若pageChangeListener为null，就初始化一个，然后重新add进去。既然问题出在TabLayoutOnPageChangeListener而viewpager的addOnPageChangeListener是public接口，那我们可以修改viewpager的listener啊，遂更改： 123456789101112131415161718192021222324// 先清空所有的pagechangelistener，会移除tablayout添加进去的那个，要在setupWithViewPager后面调用viewPager.clearOnPageChangeListeners();// 添加自己的pagechangelistener，根据上面的反射的那个思路，如果不是手动触发的滚动，就不执行tablayout的滚动viewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tablayout) &#123; boolean isTouchState; @Override public void onPageScrollStateChanged(int state) &#123; super.onPageScrollStateChanged(state); if (state == SCROLL_STATE_DRAGGING) &#123; isTouchState = true; &#125; else if (state == SCROLL_STATE_IDLE) &#123; isTouchState = false; &#125; &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; if (isTouchState) &#123; super.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; &#125;&#125;); TabLayout的抖动问题也算圆满解决了。 还有一个Fragment切换，里面的recyclerbview页面变成空白的问题待解决，先记一下。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recyclerview实现二级列表]]></title>
    <url>%2F2019%2F09%2F27%2Frecyclerview%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[二级列表是项目中经常会用到的组件，本着学习新组件的思想，决定不用ExpandableListView，而是用RecyclerView实现。 为了不重复造轮子，在github上搜索一番，看到一个还不错的项目thoughtbot/expandable-recycler-view，这个项目封装好了二级列表的整个实现，使用起来也很简单，下载项目看一下sample就多清楚了。但是这个项目有个问题，不能更新数据，recyclerview数据是初始化的时候给定的，没有后续变更数据的操作，所以修改了一下这个项目。 1. 实现动态变更数据 ExpandableGroup类增加teamId，每个分组的唯一标识 1234567891011121314151617181920212223242526272829public class ExpandableGroup&lt;T extends Parcelable&gt; implements Parcelable &#123; private int teamId; // ... public ExpandableGroup(int teamId, String title, List&lt;T&gt; items) &#123; this.teamId = teamId; this.title = title; this.items = items; &#125; protected ExpandableGroup(Parcel in) &#123; teamId = in.readInt(); // .. &#125; public int getTeamId() &#123; return teamId; &#125; public void setTeamId(int teamId) &#123; this.teamId = teamId; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(teamId); // ... &#125;&#125; 修改ExpandableList类的变量public boolean[] expandedGroupIndexes;该变量被用来记住当前分组是否展开，默认为false，用boolean数组不好的一点，在数据增加或者减少的时候，没办法把旧展开状态还原到新的数据中，修改为使用map，根据每个分组的id，来存储分组的展开状态，并在数据变更的时候，还原状态。 12345678910111213141516public class ExpandableList &#123; public List&lt;? extends ExpandableGroup&gt; groups; // 修改为使用map，对项目中其他使用该变量的地方相应的修改为根据teamId获取或更新展开状态 public SparseBooleanArray expandedGroupIndexes; public ExpandableList(List&lt;? extends ExpandableGroup&gt; groups) &#123; this.groups = groups; // 默认都为false expandedGroupIndexes = new SparseBooleanArray(); for (int i = 0; i &lt; groups.size(); i++) &#123; expandedGroupIndexes.put(groups.get(i).getTeamId(), false); &#125; &#125;&#125; 在ExpandableRecyclerViewAdapter.java中，增加更新数据的方法，进行数据的更新。 12345678910111213141516171819public void setGroups(List&lt;? extends ExpandableGroup&gt; groups) &#123; // 保留一份老的展开状态的数据 SparseBooleanArray oldIndex = this.expandableList.expandedGroupIndexes.clone(); this.expandableList.groups = groups; // 设置新的数据 // 设置新的展开状态数据 this.expandableList.expandedGroupIndexes = new SparseBooleanArray(); for (int i = 0; i &lt; groups.size(); i++) &#123; this.expandableList.expandedGroupIndexes.put(groups.get(i).getTeamId(), false); &#125; SparseBooleanArray newIndex = this.expandableList.expandedGroupIndexes; for (int i = 0; i &lt; newIndex.size(); i++) &#123; for (int j = 0; j &lt; oldIndex.size(); j++) &#123; // 如果含有老的数据的话，还原到新数据集 if (newIndex.keyAt(i) == oldIndex.keyAt(j)) &#123; newIndex.put(oldIndex.keyAt(j), oldIndex.get(oldIndex.keyAt(j))); &#125; &#125; &#125;&#125; 这样便可实现动态修改二级列表的数据，弥补了原项目不能动态修改数据的一个不足。 2. 实现类似ExpandableListview的列表悬浮在顶部效果+可分页加载RecyclerView这个功能使用比较简单的方法，在RecyclerView顶部增加一个view，在滑动的时候，该view一直在顶部展示，并且展示当前分组下的Group的名称和状态等。 顶部悬浮view实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/** * 自定义recyclerview继承relativeLayout */public class ExpandableRecyclerView extends RelativeLayout &#123; // 悬浮在顶部的view private RelativeLayout pinnedView; ImageView pinnedIcon; // 顶部悬浮view的icon，可用来表示展开状态 TextView pinnedText; // 顶部悬浮view的内容 TextView pinnedNum; // 顶部悬浮view的数据，展示当前分组成员个数 ExpandableRecyclerViewAdapter adapter; // 项目中的二级列表adapter private RecyclerView recyclerView; // 两个状态图标 private Drawable mListIndicatorExpanded; private Drawable mListIndicatorNormal; public ExpandableRecyclerView(Context context) &#123; super(context); initView(context); &#125; public ExpandableRecyclerView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(context); &#125; public ExpandableRecyclerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(context); &#125; private void initView(Context context) &#123; LayoutInflater.from(context).inflate(R.layout.expandable_recyclerview_layout, this, true); pinnedView = findViewById(R.id.expanded_recyclerview_pinned_view); pinnedIcon = findViewById(R.id.expanded_recyclerview_indicator); pinnedText = findViewById(R.id.expanded_recyclerview_name); pinnedNum = findViewById(R.id.expanded_recyclerview_number); recyclerView = findViewById(R.id.expanded_recyclerview); MyLinearLayoutManager lm = new MyLinearLayoutManager(context, LinearLayoutManager.VERTICAL, false); recyclerView.setLayoutManager(lm); mListIndicatorExpanded = context.getResources().getDrawable(R.drawable.list_indicator_expanded); mListIndicatorNormal = context.getResources().getDrawable(R.drawable.list_indicator_normal); initListener(); &#125; private void initListener() &#123; // 通过recyclerview的滑动判断顶部悬浮view展示内容 recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; // 滑动的时候悬浮框置顶 LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager(); // 获取第一个可见item位置 int firstVisibleItemPosition = lm.findFirstVisibleItemPosition(); pinnedView.setVisibility(View.VISIBLE); // 对应位置在二级列表里的坐标 该坐标包含父坐标和子坐标 ExpandableListPosition expandableListPosition = adapter.expandableList.getUnflattenedPosition(firstVisibleItemPosition); if (expandableListPosition.groupPos &lt; adapter.getGroups().size()) &#123; // 根据二级列表坐标取出group的数据，该数据包含child的数据 ExpandableGroup expandableGroup = (ExpandableGroup) adapter.getGroups().get(expandableListPosition.groupPos); // 根据展开状态设置顶部悬浮view的icon状态 pinnedIcon.setImageDrawable( adapter.isGroupExpanded(expandableGroup) ? mListIndicatorExpanded : mListIndicatorNormal); // 设置顶部悬浮view的内容 pinnedText.setText(expandableGroup.getTitle()); // // 设置顶部悬浮view的child的数量 pinnedNum.setText( expandableGroup.getItems() != null ? "(" + expandableGroup.getItems().size() + ")" : ""); pinnedView.setTag(expandableGroup); &#125; &#125; &#125;); pinnedView.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 点击悬浮框展开或伸缩列表 ExpandableGroup expandableGroup = (ExpandableGroup) pinnedView.getTag(); if (expandableGroup != null) &#123; adapter.toggleGroup(expandableGroup); recyclerView.scrollToPosition(0); &#125; if (pinnedIcon.getDrawable() == mListIndicatorNormal) &#123; pinnedIcon.setImageDrawable(mListIndicatorExpanded); &#125; else if (pinnedIcon.getDrawable() == mListIndicatorExpanded) &#123; pinnedIcon.setImageDrawable(mListIndicatorNormal); &#125; &#125; &#125;); &#125; public RecyclerView getRecyclerView() &#123; return recyclerView; &#125; private RecyclerView.AdapterDataObserver observer = new RecyclerView.AdapterDataObserver() &#123; @Override public void onChanged() &#123; super.onChanged(); // 更新顶部悬浮view updatePinnedView(); &#125; &#125;; public void setAdapter(final ExpandableRecyclerViewAdapter adapter) &#123; this.adapter = adapter; // 数据更新的时候，如果不滑动，这个时候顶部悬浮view的内容不准，所以在数据变更的时候要更新顶部悬浮view // adapter注册数据变更监听 this.adapter.registerAdapterDataObserver(observer); recyclerView.setAdapter(adapter); &#125; /** * 更新pinnedview的内容 */ private void updatePinnedView() &#123; // 查找第一个父布局 LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager(); int firstVisibleItemPosition = lm.findFirstVisibleItemPosition(); // 对应位置在列表里的坐标 ExpandableListPosition expandableListPosition = adapter.expandableList.getUnflattenedPosition(firstVisibleItemPosition); if (expandableListPosition.groupPos &lt; adapter.getGroups().size()) &#123; ExpandableGroup expandableGroup = (ExpandableGroup) adapter.getGroups().get(expandableListPosition.groupPos); pinnedIcon.setImageDrawable( adapter.isGroupExpanded(expandableGroup) ? mListIndicatorExpanded : mListIndicatorNormal); pinnedText.setText(expandableGroup.getTitle()); pinnedNum.setText(expandableGroup.getItems() != null ? "(" + expandableGroup.getItems().size() + ")" : ""); pinnedView.setTag(expandableGroup); &#125; &#125; // java.lang.IndexOutOfBoundsException: Inconsistency detected.Invalid item position // 这个crash据说是recyclerview的bug，google建议重写下面的方法改成false，我试试 class MyLinearLayoutManager extends LinearLayoutManager &#123; @SuppressWarnings("SameParameterValue") MyLinearLayoutManager(Context context, int orientation, boolean reverseLayout) &#123; super(context, orientation, reverseLayout); &#125; @Override public boolean supportsPredictiveItemAnimations() &#123; return false; &#125; &#125;&#125; 使用方就像正常的使用RecyclerView一样使用该自定义RecyclerView，最后顶部的悬浮view效果如下： 3. ExpandableRecyclerView实现分页加载对于可能数据量很大的数据来说，分页加载是必不可少的，一次大量的加载请求数据会造成不必要的浪费。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ExpandableRecyclerView extends RelativeLayout &#123; SparseIntArray pageMap = new SparseIntArray(); // 记录每个分组当前分页的页数 boolean isNeedPageUpdateData = false; // 是否要分页加载数据 // 分页加载滑动到底部回调，由使用方决定下一页的数据加载 PageUpdateDataCallback pageUpdateDataCallback; int pageSize = 50; // .... private void initListener() &#123; recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; // ... // 向上滚动 清空数据 if (dy &lt; 0) &#123; for (int i = 0; i &lt; pageMap.size(); i++) &#123; pageMap.put(pageMap.keyAt(i), 1); &#125; &#125; // 向下滚动 分页加载 if (isNeedPageUpdateData &amp;&amp; dy &gt; 0) &#123; // 获取最后一个可见item在列表中的位置 int lastVisiableItemPos = lm.findLastVisibleItemPosition(); // 对应位置在列表里的坐标 ExpandableListPosition lastExpandableListPos = adapter.expandableList.getUnflattenedPosition(lastVisiableItemPos); ExpandableGroup expandableGroup = (ExpandableGroup) adapter.getGroups().get(lastExpandableListPos.groupPos); int childPos = lastExpandableListPos.childPos; int page = pageMap.get(expandableGroup.getTeamId()); // 如果最后一个可见item的childPos等于当前分组的分页加载总数量，表示滑动到当前分页的最后一条数据，可以开始加载下一页数据 if (childPos == page * pageSize) &#123; if (pageUpdateDataCallback != null) &#123; page++; pageMap.put(expandableGroup.getTeamId(), page); // 回调给使用方 pageUpdateDataCallback.getPageData(expandableGroup, page); &#125; &#125; &#125; &#125; &#125;); &#125; /** * 分页更新数据的size */ public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; /** * 是否需要分页更新数据 */ public void setNeedPageUpdateData(boolean needPageUpdateData) &#123; isNeedPageUpdateData = needPageUpdateData; &#125; /** * 分页更新数据的callback，使用方自己决定怎么更新数据 */ public void setPageUpdateDataCallback(PageUpdateDataCallback pageUpdateDataCallback) &#123; this.pageUpdateDataCallback = pageUpdateDataCallback; &#125;&#125;// 使用方设置使用分页加载 分页加载的数量和分页监听recyclerview.setPageSize(PAGE_MAX_SIZE);recyclerview.setNeedPageUpdateData(true);recyclerview.setPageUpdateDataCallback(new ExpandableRecyclerView.PageUpdateDataCallback() &#123; @Override public void getPageData(ExpandableGroup group, int page) &#123; // 加载下一页数据 &#125;&#125;); 改造完后，该项目基本实现了二级列表+动态更新+分页加载功能，算是一个比较完善的二级列表RecyclerView了，后续有时间继续研究一下看能否把RecyclerView的局部刷新功能也加上。最后，再次感谢thoughtbot/expandable-recycler-view项目，也是这个项目封装的比较好，才能实现这些改造。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView实现类型微信的全文功能]]></title>
    <url>%2F2018%2F11%2F22%2FTextView%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%BE%AE%E4%BF%A1%E7%9A%84%E5%85%A8%E6%96%87%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[在最近的项目中，有个列表需要展示类似微信朋友圈的全文功能，点击全文展示所有的内容，点击隐藏全文，展示原本的文本。 设置TextView最多只能展示5行，超过5行的时候展示省略号（TextView设置最大行数的同时支持Span属性的一些坑，已经在LinkMovementMethod那些坑中描述）。我们只要知道当前展示的文字长度超过了5行，就可以知道是否要展示全文按钮，可以使用addOnGlobalLayoutListener（）在TextView绘制完成后进行展示文字长度的判断，我选择自定义TextView，在onMeasure（）中进行判断。 一开始在网上搜罗了一些方法后，感觉还挺简单的，码上代码： 12345678910111213141516171819202122232425public class SpannableTextView extends TextView &#123; private TextViewShowCallback callback; public SpannableTextView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Layout mainLayout = getLayout(); int lineCount = mainLayout.getLineCount(); // 获取当前TextView展示的行数 // mainLayout.getLineEnd(lineCount - 1)获取当前TextView展示的最后一个字符的位置 callback.configMoreText(lineCount, mainLayout.getLineEnd(lineCount - 1)); &#125; public void setCallback(TextViewShowCallback callback) &#123; this.callback = callback; &#125; // 一个callback来告诉textview的父view展示了多少，当前行末位置 public interface TextViewShowCallback &#123; void configMoreText(int lineCount, long lineEnd); &#125;&#125; 在使用了这个TextView的RecyclerView的adapter里面 123456789101112131415161718linkText.setCallback(new SpannableTextView.TextViewShowCallback() &#123; @Override public void configMoreText(int lineCount, long lineEnd) &#123; // 不展开的时候最多只有5行，少于5行不展示加载更多，等于5行才判断是否要展示 if (lineCount == 5) &#123; // 文字已经全部展示不需要显示下边展示更多按钮 if (msg.length() &lt;= lineEnd) &#123; return; &#125; linkMore.setVisibility(View.VISIBLE); linkMore.setText("全文"); &#125; else if (lineCount &gt; 5) &#123; // 展开后才会超过五行 linkMore.setVisibility(View.VISIBLE); linkMore.setText("收起"); &#125; &#125;&#125;); 跑了一下，看到全文和收起可以正常使用了，美滋滋的以为so easy啊。然鹅，过不了多久就收到qa的bug邮件，说她的文本都没有全文按钮。不能啊，我这明明好好的呢，一定是见鬼了（我的代码不存在bug的，不接受反驳╭(๑¯д¯๑)╮）。多拿了几个机型跑了一下，发现Android 8.0以上的机器都不能正常显示全文按钮，跟debug后发现是lineEnd的值不准，返回的是全文的长度。翻google无果后，就想还是得靠自己，开始翻源码，然后！！！就发现了一个大坑。。 在sdk 27的源码中，getLineEnd（）源码如下： 12345678910111213/** * Return the text offset after the last character on the specified line. */public final int getLineEnd(int line) &#123; return getLineStart(line + 1);&#125;/** * Return the text offset of the beginning of the specified line ( * 0&amp;hellip;getLineCount()). If the specified line is equal to the line * count, returns the length of the text. */public abstract int getLineStart(int line); 看到getLineStart上面写着，如果参数line和目前TextView的line一致的话，就返回文本的全部长度，我整个人陷入了沉思。。。这么存在的一个方法有什么用啊，什么用。。。为什么Android 5.0可以用啊，可以用。。。都这样了，那只能自己想办法计算了，最后计算方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SpannableTextView extends TextView &#123; private TextViewShowCallback callback; public SpannableTextView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Layout mainLayout = getLayout(); int lineCount = mainLayout.getLineCount(); int leftLineWidth = 0; // 第五行的文本宽度 TextPaint textPaint = getPaint(); // 文字刚好等于5行的情况，需要另外计算已经显示的文字长度 if (lineCount == getMaxLines()) &#123; // 第四行末尾的文字长度 int lineEnd = mainLayout.getLineEnd(lineCount - 2); // 剩下的文本 String leftStr = getText().subSequence(lineEnd, getText().length()).toString(); int i = 0; for (; i &lt; leftStr.length(); i++) &#123; // 获取每个字符的宽度，单位为pixel leftLineWidth += textPaint.measureText(leftStr, i, i + 1); // 如果超过TextView的宽度，说明第五行展示完了 if (leftLineWidth &gt; getMeasuredWidth()) &#123; break; &#125; &#125; // 加上第五行展示的字符个数，得到最终的lineEnd lineEnd += i; callback.configMoreText(lineCount, lineEnd); return; &#125; callback.configMoreText(lineCount, mainLayout.getLineEnd(lineCount - 1)); &#125; public void setCallback(TextViewShowCallback callback) &#123; this.callback = callback; &#125; public interface TextViewShowCallback &#123; void configMoreText(int lineCount, long lineEnd); &#125;&#125; 在Android 5.0 7.0 8.0都跑了一下，这下真的可以正常展示。。。 写代码一分钟，解bug一天。。。╮（﹀＿﹀）╭ 最后附上在RecyclerView中的item里，点击全文和收起的实现代码： 12345678910111213141516171819202122232425262728293031// 标志展开的item的位置int opened = -1;// 在相关item的初始化位置// 是否是已经展开的if (opened == position) &#123; linkText.setMaxLines(Integer.MAX_VALUE); linkText.setEllipsize(null);&#125; else &#123; linkText.setMaxLines(5); linkText.setEllipsize(TextUtils.TruncateAt.END);&#125;// 全文或者收起按钮点击监听linkMore.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (opened == getAdapterPosition()) &#123; // 已经展开，就关闭 opened = -1; notifyItemChanged(getAdapterPosition()); &#125; else &#123; int oldOpened = opened; opened = getAdapterPosition(); notifyItemChanged(oldOpened); notifyItemChanged(opened); &#125; &#125;&#125;);// 若需要自己修改itemchanged的动画时长等linkRecyclerview.getItemAnimator().setChangeDuration(300);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkMovementMethod那些坑]]></title>
    <url>%2F2018%2F11%2F21%2FLinkMovementMethod%2F</url>
    <content type="text"><![CDATA[最近一个需求中，需要对Textview中的文本url进行高亮显示，并自定义点击操作。按照所学知识，开始码代码。 按照交互要求，Textview最多五行，自动显示省略号: 12345678910111213&lt;TextView android:id="@+id/link_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="18dp" android:layout_marginTop="10dp" android:layout_marginRight="18dp" android:ellipsize="end" android:lineSpacingExtra="2dp" android:maxLines="5" android:singleLine="false" android:textColor="@color/c_2_new" android:textSize="@dimen/f_2" /&gt; 截取文本中的url字段，设置url的span 123456789// ...if (JudgmentUtil.isNotEmpty(url)) &#123; textUrlMsg.append(url).append(" "); // 自定义span UrlSpanListener clickableSpan = new UrlSpanListener(context, url); textUrlMsg.setSpan(clickableSpan, startIndex, textUrlMsg.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);&#125;// ... 123456789101112131415161718192021public class UrlSpanListener extends ClickableSpan &#123; private String mUrl; // 当前点击的链接 private final Context context; public UrlSpanListener(Context context, String url) &#123; this.context = context; mUrl = url; &#125; @Override public void onClick(@NonNull View widget) &#123; // 自定义点击操作 &#125; @Override public void updateDrawState(TextPaint ds) &#123; super.updateDrawState(ds); // 设置颜色等span属性 ds.setColor(context.getResources().getColor(R.color.c_1)); &#125;&#125; 给Textview设置文本，并设置movementmethod使span点击操作可以执行。 123TextView linkText = itemView.findViewById(R.id.link_text);linkText.setMovementMethod(LinkMovementMethod.getInstance());linkText.setText(textUrlMsg); 写完代码，美滋滋等待build，想着分分钟解决了需求。然鹅，事情并没有想象的那么简单！！！跑完后发现，textview中的文本，在超过五行后自动省略，但是，并没有显示省略号，文本还会莫名出现向上动了半截字的画面！！！向下面一样 在问遍组内大佬，百度半天，谷歌半天没有结果后（ps：谷歌上说，用SpannableStringBuilder文本，会导致TextView算不准什么时候显示省略号，要自己截取文本添加省略号来实现，这都是骗！人！的！），一个大佬偶然说，你这textview好像就是向上滚动了，我记得textview有个设置不可滚动的属性，你看看设为none后可不可以用。听完火速打来xml开始寻找这个属性，寻找一圈后没找到大佬说的属性，但是给了我灵感，遂谷歌如何设置textview可滚动，谷歌说textview本身自带滚动，若要实现滚动效果，给textview设置movementmethod即可。 12// 设置后textview便可以滚动linkText.setMovementMethod(ScrollingMovementMethod.getInstance()); 再顺藤摸瓜看了一眼，LinkMovementMethod继承自ScrollingMovementMethod，好了，自此知道了问题所在。 因为LinkMovementMethod继承自ScrollingMovementMethod，所以也继承了滚动属性，textview中的文本若可以滚动，便不会自动省略和显示省略号，又因为需求中的textview外层是recyclerview，大部分的滚动监听都被recyclerview捕获，个别触发了textview的滚动导致个别textview文字向上滚动了一点。去掉linkText.setMovementMethod(LinkMovementMethod.getInstance());后，文字可以正常省略了，也有省略号了，也不会自己滚动了，然鹅，span就不能点击了。既然这样，只好自己做点击事件了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// textview点击监听linkText.setOnTouchListener(new View.OnTouchListener() &#123; long startTime = 0; @Override public boolean onTouch(View v, MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; startTime = System.currentTimeMillis(); &#125; TextView tv = (TextView) v; CharSequence text = tv.getText(); if (text instanceof SpannedString) &#123; if (action == MotionEvent.ACTION_UP) &#123; // 避免长按和点击冲突，如果超过300毫秒，认为是在长按，不执行点击操作 if (System.currentTimeMillis() - startTime &gt; 300) &#123; return false; &#125; int x = (int) event.getX(); int y = (int) event.getY(); x -= tv.getTotalPaddingLeft(); y -= tv.getTotalPaddingTop(); x += tv.getScrollX(); y += tv.getScrollY(); Layout layout = tv.getLayout(); int line = layout.getLineForVertical(y); int off = layout.getOffsetForHorizontal(line, x); UrlSpanListener[] link = ((SpannedString) text).getSpans(off, off, UrlSpanListener.class); if (link.length != 0) &#123; link[0].onClick(tv); return true; &#125; &#125; &#125; return false; &#125; &#125;); 自此，问题完美解决，需求完美实现~(˘▾˘)~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战4-while和for循环]]></title>
    <url>%2F2018%2F10%2F09%2FKotlin%E5%AE%9E%E6%88%984-while%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[while循环Kotlin的while循环和do-while循环的语法和java一样 12345678// 当condition为true时执行while (condition) &#123; // ...&#125;// 第一次无条件执行，后当condition为true时执行do &#123; // ...&#125; while(condition) for循环区间和数列在Kotlin中，没有传统的JAVA for循环，为了替代这种最常见的for循环，Kotlin使用了区间的概念。 区间本质上是两个值的间隔，这两个值通常是数字，一个起始值，一个结束值。使用 .. 运算符表示区间： 1val oneToTen = 1 .. 10 // ..是包含结束的封闭区间，包含10 使用when实现Fizz-Buzz游戏 1234567891011fun fizzBuzz(i: Int) = when &#123; i % 15 == 0 -&gt; "FizzBuzz " i % 3 ==0 -&gt; "Fizz " i % 5 == 0 -&gt; "Buzz " else -&gt; "$i "&#125;for(i in 1..100) &#123; print(fizzBuzz(i))&#125;// 1 2 Fizz 3 4 Buzz .... 我们修改规则，从100开始倒计数并且只计算偶数 1234for(i in 100 downTo 1 setp 2) &#123; print(fizzBuzz(i))&#125;// Buzz 98 Fizz 94 92 FizzBuzz .... 因为..语法创建的始终是包含结束值得闭区间，若需要不包含结束值的半闭合区间，可以使用until函数，例如循环for(i in 0 until size)，等同于for(i in 0 .. size -1)，但前者更加方便，意图更加清晰。 迭代map12345678val binaryReps = TreeMap&lt;Char, String&gt;() // 字符的二进制mapfor(c in 'A'..'F' ) &#123; val binary = Integer.toBinaryString(c.toInt()) //asc转二进制 binaryReps[c] = binary // 根据键c把值存到map中&#125;for((letter, binary) in binaryReps) &#123; // 迭代map，把键和值赋给变量 println('$letter = $binary')&#125; 使用”in”检查集合和区间的成员使用in检查一个值是否在区间中，或者使用!in检查一个值是否不在区间中 12fun isLetter(c: Char) = c in 'a'..'f'|| c in 'A'..'F'fun isNotDigital(c: Char) = c !in '0'..'9']]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战3-枚举和when]]></title>
    <url>%2F2018%2F07%2F06%2FKotlin%E5%AE%9E%E6%88%983-%E6%9E%9A%E4%B8%BE%E5%92%8Cwhen%2F</url>
    <content type="text"><![CDATA[声明枚举类声明一个简单的枚举类123enum class Food &#123; FRUID, WATER, NOODLE&#125; Kotlin用了enum class两个关键字来声明枚举类，而java只用了enum一个关键字。在Kotlin中，enum是一个软关键字 ：只有当它出现在class前面时才有特殊的意义，在其他地方可以把它当成普通的名称使用。 声明一个带属性的枚举类123456789enum class Color(val r: Int, val g: Int, val b: Int) &#123; // 声明枚举常量的属性 // 在每个常量创建的时候指定属性值 RED(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),INDIGO(75, 0, 130), VIOLET(238, 130, 238); // 给枚举类定义一个方法 fun rgb() = (r * 255 + g) * 255 + b&#125;// 输出&gt;&gt;&gt; println(Color.BLUE.rgb())&gt;&gt;&gt; 255 如果要在枚举类中定义任何方法，都要使用分号 把枚举常量列表和方法定义分开，这是Kotlin语法中唯一必须使用分号的地方。 使用”when”处理枚举类在Kotlin中，与java的switch相对应的结构，是when。和if相似，when是一个有返回值的表达式，因此可以写一个直接返回when表达式的表达式体函数。 1234567891011121314// 直接返回when表达式fun getMnemonic(color: Color) = when (color) &#123; Color.RED -&gt; "Richard" Color.ORANGE -&gt; "Of" Color.YELLOW -&gt; "York" Color.GREEN -&gt; "Gave" Color.BLUE -&gt; "Battle" Color.INDIGO -&gt; "In" Color.VIOLET -&gt; "Vain" &#125;// 输出&gt;&gt;&gt; println(getMnemonic(Color.BLUE))&gt;&gt;&gt; Battle 和java不一样的是，不需要在每个分支都写上break语句，如果匹配成功，只有对应的分支会执行，也可以把多个分支的值合并到同一个分支，只需要用逗号隔开这些值。 123456789fun getWarmth(color: Color) = when (color) &#123; Color.RED, Color.ORANGE, Color.YELLOW -&gt; "warm" Color.GREEN -&gt; "neutral" Color.BLUE, Color.INDIGO, Color.VIOLET -&gt; "cold" &#125;// 输出&gt;&gt;&gt; println(getWarmth(Color.ORANGE))&gt;&gt;&gt; warm 这些例子使用了枚举常量的完整名称，即指定了枚举类的名称Color，可以通过导入这些常量来简化代码。 123456fun getWarmth(color: Color) = when (color) &#123; RED, ORANGE, YELLOW -&gt; "warm" GREEN -&gt; "neutal" BLUE, INDIGO, VIOLET -&gt; "cold" &#125; 在”when”结构中使用任意对象Kotlin中的when结构比java中的switch要强大得多。switch要求必须使用常量（枚举常量，字符串或者数字字面量）作为分支条件，when允许使用任意对象。 12345678910fun mix(c1: Color, c2: Color) = when (setOf(c1, c2)) &#123; setOf(RED, YELLOW) -&gt; ORANGE setOf(YELLOW, BLUE) -&gt; GREEN setOf(BLUE, VIOLET) -&gt; INDIGO else -&gt; throw Exception("Dirty color") &#125;// 输出&gt;&gt;&gt; println(mix(VIOLET, BLUE).ordinal)&gt;&gt;&gt; INDIGO Kotlin标准函数库中有一个setOf函数可以创建出一个Set，它会包含所有指定为函数实参的对象。set集合的条目顺序并不重要，只要两个set包含一样的条目，它们就是相等的。 使用不带参数的”when”上面的方法，在每次调用这个函数的时候，都会创建一些Set实例，仅仅用来检查两种给定的颜色是否和另外的颜色匹配，如果这个函数调用频繁，可以使用另外一种方式，来避免创建额外的垃圾对象。代码可读性会变差，但是能达到更好的性能。 1234567fun mixOptimized(c1: Color, c2: Color) = when &#123; //没有实参传给when (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt; GREEN (c1 == BLUE &amp;&amp; c2 == VIOLET) || (c2 == VIOLET &amp;&amp; c1 == BLUE) -&gt; INDIGO else -&gt; throw Exception("Dirty color") &#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections.sort()的使用]]></title>
    <url>%2F2018%2F05%2F18%2FCollections.sort()%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[String、Integer等基本类型已经实现了Comparable接口，可以直接使用Collections.sort()进行排序。 12345static List&lt;Integer&gt; intList = Arrays.asList(2, 3, 1);// ...Collections.sort(intList);// 输出 1,2,3 默认为正序排序，若想自定义排序，可以自己实现Comparator接口的compare方法。 1234567891011Coolections.sort(intList, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer 02) &#123; // 返回值为int，大于0表示正序，小于0表示逆序 return o1-o1; &#125; &#125;);// 输出 3,2,1 接下来是自定义类的排序，自定义一个类： 123456789101112131415161718192021222324252627public class Emp &#123; private int empno; private String ename; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Emp(int empno, String ename) &#123; super(); this.empno = empno; this.ename = ename; &#125; @Override public String toString() &#123; return "empno:\t"+empno+"\tename:\t"+ename; &#125;&#125; 首先直接使用Collections.sort()进行排序 12345678910static List&lt;Emp&gt; empList; static &#123; Emp emp1 = new Emp(2,"Guan YunChang"); Emp emp2 = new Emp(3,"Zhang Fei"); Emp emp3 = new Emp(1,"Liu Bei"); empList = Arrays.asList(emp1,emp2,emp3); &#125;// ...Collections.sort(empList); 此时会报错： The method sort(List) in the type Collections is not applicable for the arguments (List) 意思是参数类型为List时，sort方法无法执行，原因是泛型没有继承Comparable接口。让Emp类实现Comparable接口并实现compareTo方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class Emp implements Comparable&lt;Emp&gt;&#123; private int empno; private String ename; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Emp(int empno, String ename) &#123; super(); this.empno = empno; this.ename = ename; &#125; @Override public int compareTo(@NonNull Emp another) &#123; // 按员工姓名逆序排序 return another.getEname().compareTo(this.getEname()); &#125; @Override public String toString() &#123; return "empno:\t"+empno+"\tename:\t"+ename; &#125;&#125;// 这时候调用Collections.sort(empList);// 输出// Zhang Fei// Liu Bei// Guan YunChang 或者使用第二个方法，调用Collections.sort(List, new Comparator() {});方法，并实现comparator的compare方式 123456789101112131415// 调用的时候Collections.sort(empList, new Comparator&lt;Emp&gt;() &#123; @Override public int compare(Emp e1, Emp e2) &#123; // 按员工姓名正序排序 return e1.getEname().compareTo(e2.getEname()); &#125; &#125;);// 输出// Guan YunChang// Liu Bei// Zhang Fei 总结： 1.对于String或Integer这些已经实现Comparable接口的类来说，可以直接使用Collections.sort方法传入list参数来实现默认方式（正序）排序； 2.如果不想使用默认方式（正序）排序，可以通过Collections.sort传入第二个参数类型为Comparator来自定义排序规则； 3.对于自定义类型(如本例子中的Emp)，如果想使用Collections.sort的方式一进行排序，可以通过实现Comparable接口的compareTo方法来进行，如果不实现，则参考第2点；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serialiable和Parceble的使用]]></title>
    <url>%2F2018%2F05%2F16%2FSerialiable%E5%92%8CParceble%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Serializable使用1234567public class User implements Serializable &#123; private static final long serialVersionUID = 2737236472349823L; public int userId; public String userName; public boolean isMale;&#125; 类实现Serializable接口，即可自动实现序列化过程。 serialVersionUID标识可以指定，也可以不指定。serialVersionUID用来辅助序列化和反序列化过程，序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同，才可以被正常反序列化。若不指定，编辑器根据当前类的结构自动生成hash值作为serialVersionUID，但若类发生变化时，比如增加或删除某些成员变量，系统自动重新计算hash值并赋值给serialVersionUID，这个时候当前类的serialVersionUID和序列化数据的serialVersionUID不一致，反序列会失败。（目前使用中好像没发现这个问题，为什么？？？） 重写序列化和反序列化过程1234567private void writeObject(java.io.ObjectOutputStream out) throws IOException &#123; // write 'this' to 'out'...&#125;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException &#123; // populate the fields of 'this' from the data in 'in'...&#125; transient关键字:加上transient关键字的变量，不会被序列化。 Parcelable接口使用123456789101112131415161718192021222324252627282930313233343536373839404142434445public class User implements Parcelable &#123; public int userId; public String userName; public boolean isMale; public Book book; public User(int userId, String userName, boolean isMale) &#123; this.userId = userId; this.userName = userName; this.isMale = isMale; &#125; // 内容描述 public describeContents() &#123; return 0; &#125; // 序列化过程 public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale ? 1 : 0 ); // boolean不能序列化，只能转化成int out.writeParcelable(book, 0); &#125; // 反序列化过程 public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123; public User createFromParcel(Parcel in) &#123; return new User(in); &#125; public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; private User(Parcel in) &#123; userId = in.readInt(); userName = in.readString(); isMale = in.readInt() == 1; book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125; &#125; Parcelable的方法说明 方法 功能 标记位 createFromParcel(Parcel in) 从序列化的对象中创建原始对象 newArray(int size) 创建指定长度的原始对象数组 User(Parcel in) 从序列化的对象中创建原始对象 writeToParcel(Parcel out, int flags) 将当前对象写入序列化结构中，flags有0和1两种，为1标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0 PARCELABLE_WRITE_RETURN_VAL describeContents 返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0 CONTENTS_FILE_DESCRIPTOR 区别Serializable是Java中的序列化接口，使用起来简单但开销大，需要大量的I/0操作。Parcelable是Android中的序列化方式，更适合在Android平台上使用，虽然使用起来稍微麻烦，但是效率高。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android gradle配置之manifestPlaceholders]]></title>
    <url>%2F2018%2F04%2F18%2FAndroid%20gradle%E9%85%8D%E7%BD%AE%E4%B9%8BmanifestPlaceholders%2F</url>
    <content type="text"><![CDATA[在开发应用中，有时候需要接入第三方sdk，而第三方sdk需要申请的key有时候又分为发布版和测试版，经常在测试开发的时候填写key，在发布版时忘记替换成发布版的key，导致发布版应用不能使用。这时候就需要给不同的版本配置不同key。 manifestPlaceholders就可以用来在gradle中为androidmanifest配置不同版本的key值。 在AndroidManifest.xml中: 123&lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="$&#123;BAIDU_LBS_API_KEY&#125;" /&gt; 在moudle的gradle文件中: 1234567891011buildTypes &#123; debug &#123; // .... manifestPlaceholders = [BAIDU_LBS_API_KEY: "debugkey"] &#125; release &#123; // .... manifestPlaceholders = [BAIDU_LBS_API_KEY: "releasekey"] &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统应用信息中存储和缓存的计算方法]]></title>
    <url>%2F2018%2F02%2F27%2FAndroid%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%AD%98%E5%82%A8%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[进入设置界面，查看每个应用占用的存储空间时，有几样数据，计算方法如下：应用，由三项相加而成 /data/data/com.myapp/lib，即so库文件夹大小 /data/app/com.myapp-1.apk，原始apk文件的复制 /data/dalvik-cache/data@app@com.myapp-1.apk@classes.dex，dalvik虚拟机对dex文件的缓存 USB存储(应用) 把程序装到（或移到）sd卡后的大小。/sdcard/Android/…，参考“应用”项 数据 /data/data/com.myapp/目录大小 - cache子目录大小 - lib子目录大小 SD卡 /sdcard/Android/data/com.myapp/目录大小 - /sdcard/Android/data/com.myapp/cache目录大小 缓存 /data/data/com.myapp/cache目录大小 + /sdcard/Android/data/com.myapp/cache目录大小]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recycleview的简单使用]]></title>
    <url>%2F2018%2F02%2F07%2FRecycleview%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[xmlactivity_main.xml 12345678910111213141516171819202122232425262728&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.yangqiuyan.clickdemo.MainActivity"&gt; &lt;Button android:id="@+id/add_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="add" /&gt; &lt;Button android:id="@+id/remove_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/add_button" android:text="remove" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/my_recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@id/remove_button" android:scrollbars="vertical" /&gt;&lt;/RelativeLayout&gt; MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() &#123; var mMyAdapter: MyAdapter? = null var mLayoutManager: LinearLayoutManager? = null var mRecyclerView: RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initData() initView() initListener() &#125; fun initData() &#123; mMyAdapter = MyAdapter(this, getData()) mLayoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &#125; fun initView() &#123; mRecyclerView = findViewById(R.id.my_recyclerview) // 设置布局管理器 mRecyclerView!!.layoutManager = mLayoutManager // 设置适配器 mRecyclerView!!.adapter = mMyAdapter // 设置recycleview添加和移除动画 mRecyclerView!!.itemAnimator = DefaultItemAnimator() &#125; fun getData(): ArrayList&lt;String&gt; &#123; var data = ArrayList&lt;String&gt;() (0 until 25).mapTo(data) &#123; "item" + it &#125; return data &#125; fun initListener() &#123; add_button.setOnClickListener &#123; mMyAdapter!!.addNewItem() &#125; remove_button.setOnClickListener &#123; mMyAdapter!!.deleteitem() &#125; &#125;&#125; MyAdapter.java12345678910111213141516171819202122232425262728293031323334353637383940414243class MyAdapter(context: Context, data: ArrayList&lt;String&gt;) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; var context: Context? = null var data: ArrayList&lt;String&gt;? = null init &#123; this.context = context this.data = data &#125; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; var view = LayoutInflater.from(context).inflate(R.layout.recycleview_item, parent, false) var viewHolder = ViewHolder(view) return viewHolder &#125; override fun getItemCount(): Int &#123; return data!!.size &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; holder!!.textview!!.text = data!![position] &#125; class ViewHolder(itemView: View?) : RecyclerView.ViewHolder(itemView) &#123; var textview: TextView? = null init &#123; textview = itemView?.findViewById(R.id.textview) &#125; &#125; fun addNewItem() &#123; data!!.add(1, "new item") notifyItemInserted(1) &#125; fun deleteitem() &#123; data!!.removeAt(1) notifyItemRemoved(1) &#125;&#125; 每个item的布局文件这里就不贴出来。]]></content>
      <categories>
        <category>Kotlin</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为手机兼容性处理]]></title>
    <url>%2F2017%2F12%2F12%2Fandroid-%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[华为Toast显示因为华为系统对Toast进行了定制，所以如果两个触发时机非常接近的Toast，华为只会显示一个。例: 12Toast.makeText(this, "this is toast 1", Toast.LENGTH_SHORT).show();Toast.makeText(this, "this is toast 2", Toast.LENGTH_Long).show(); 则华为手机只会显示最后一个toast。 背景绘制最近在做项目的时候，需要给一个Fragment的背景绘制上倾斜的水印，水印的绘制通过自定义drawable，重写draw()方法生成一张drawable，然后用setBackground()设置为背景。 水印生成的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WarterMarkDrawable extends Drawable &#123; Context context; String markStr = ""; int textColor = Color.BLACK; int textSize = 30; int backgroundColor = Color.WHITE; int rotate = -30; int alpha = 41; int density = 10; private Paint paint = new Paint(); public WarterMarkDrawable(Context context, String watermark) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width = getBounds().right + 200; int height = getBounds().bottom + 200; canvas.drawColor(backgroundColor); paint.setColor(textColor); paint.setAntiAlias(true); paint.setTextSize(textSize); canvas.rotate(rotate); canvas.save(); float textWidth = paint.measureText(markStr); int index = 0; int sheight = 100; float swidth = textWidth * 2 + 20; for (int positionY = sheight; positionY &lt;= height; positionY += sheight) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += swidth) &#123; canvas.drawText(markStr, positionX, positionY, paint); &#125; &#125; canvas.restore(); &#125; @Override public void setAlpha(int i) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125;&#125; 一开始这方法生成的drawable都没有问题，也没有造成内存泄露。直到遇到了华为MT7 4.4系统，用这方法生成水印背景，导致所有设置该背景的Fragment内容全部变成倾斜。在前辈的帮助下，定位问题，可能是在draw()方法里面绘制背景的时候，用canvas.rotate(rotate);对整个画布进行旋转，华为MT7 4.4系统应该把所有的内容(包括listview等)都绘制在canvas上面，是得在进行选择的时候，不是对该背景的canvas进行旋转，而是旋转了所有的view。 更新：经过多个机型匹配发现，这是Android4.4手机系统都会有的问题 前辈说在onDraw()函数加canvas.save()和canvas.restore()可以解决问题，还没验证 对生成自定义drawable进行了改造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class WarterMarkDrawable extends Drawable &#123; Context context; String markStr = ""; int textColor = Color.BLACK; int textSize = 30; int backgroundColor = Color.WHITE; int rotate = -30; int alpha = 41; int density = 10; private Paint paint = new Paint(); Bitmap bitmap = null; public WarterMarkDrawable(Context context, String watermark) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; &#125; public WarterMarkDrawable(Context context, String watermark, Bitmap bitmap) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; this.bitmap = bitmap; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width; int height; // 只有mt7才会进入该方法 在外面将水平drawable转换成bitmap后再旋转bitmap 绘制在canvas上 if (bitmap != null) &#123; Matrix matrix = new Matrix(); // 根据中点旋转 matrix.postRotate(rotate, bitmap.getWidth() / 2, bitmap.getHeight() / 2); canvas.drawBitmap(bitmap, matrix, paint); &#125; else &#123; // 华为MT7不能直接旋转画布 先生成一个水平的不旋转的drawable if (DeviceInfo.MODEL.getModel().contains("HUAWEI MT7")) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); width = wm.getDefaultDisplay().getWidth() + 200; height = wm.getDefaultDisplay().getHeight() + 200; &#125; else &#123; // 普通系统走正常的生成水印代码 width = getBounds().right + 200; height = getBounds().bottom + 200; canvas.rotate(rotate); &#125; canvas.drawColor(backgroundColor); paint.setColor(textColor); paint.setAntiAlias(true); paint.setTextSize(textSize); canvas.save(); float textWidth = paint.measureText(markStr); int index = 0; int sheight = 100; float swidth = textWidth * 2 + 20; for (int positionY = sheight; positionY &lt;= height; positionY += sheight) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += swidth) &#123; canvas.drawText(markStr, positionX, positionY, paint); &#125; &#125; canvas.restore(); &#125; &#125; @Override public void setAlpha(int i) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125;&#125; 增加了一个bitmap成员，在华为MT7 系统上，先生成一个不旋转的水平的水印背景drawable，将改drawable转化成bitmap，然后对该bitmap进行旋转，绘制在canvas上，避免了旋转canvas。 在外围调用的时候 12345678910111213141516// 先生成一张drawable 若是华为MT7系统 则生成的是不旋转的水平drawableWarterMarkDrawable waterDrawable = new WarterMarkDrawable(context, watermark);// 华为MT7不能直接在画布上旋转if (DeviceInfo.MODEL.getModel().contains("HUAWEI MT7")) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 将drawable转化成bitmap int width = wm.getDefaultDisplay().getWidth() + 200; int height = wm.getDefaultDisplay().getHeight() + 200; Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); waterDrawable.draw(canvas); // 再生成一次drawable，这次传入bitmap后，会将改bitamp选择并绘制在canvas上，而不是选择canvas WarterMarkDrawable bitmapDrawable = new WarterMarkDrawable(context, watermark, bitmap);&#125; // ... 将waterDrawable 或 bitmapDrawable设置成view的背景，即完成水印背景的绘制 总结：简直被华为系统坑爆了。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android string资源的用法]]></title>
    <url>%2F2017%2F11%2F28%2Fandroid-string%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Android string的用法 原文地址：%1$s %1$d Android string 整型例如”我今年23岁了”，可以在string.xml文件中这样写 1&lt;string name="old"&gt;我今年%1$d岁了&lt;/string&gt; 在程序中这样使用 12String str = getResource().getString(R.string.old);String year = String.format(str, 23); 将%1$d替换为23。%1$d的意思为，name=”old”这个字符串中，第一个参数为整型。如果一个string资源中，有两个替换的部分，则第二个写为%2$(X)，X为整型或string型，以此类推。 string型例如，”我的名字叫李四，我来自北京”，在string.xml资源文件中，可以写成: 1&lt;string name="info"&gt;我的名字叫%1$s,我来自%2$s。&lt;/string&gt; 在程序中写成: 1String info = String.format(getResource().getString(R.string.info), "李四","北京");]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java enum的用法]]></title>
    <url>%2F2017%2F11%2F21%2Fjava-enum%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java enum的用法 原文地址：Java enum的用法 主要方法 name()：获取定义的枚举值的名称 ordinal()：获取枚举值的位置，位置从0开始 用法常量123public enum Color&#123; RED,GREEN,BLANK,YELLOW&#125; 向枚举中添加新方法如果打算自定义自己的方法，必须在enum实例序列的最后一个添加一个分号，而且Java要求必须先定义enum实例。 123456789101112131415161718192021222324252627282930313233public enum Color&#123; RED("红色",1), GREEN("绿色",2), BLANK("白色"，3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for(Color c : Color.values()) &#123; if(c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // 构造器 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战2 — 类和属性]]></title>
    <url>%2F2017%2F11%2F20%2FKotlin%E5%AE%9E%E6%88%982-%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Kotlin实战2 — 类和属性属性类的概念就是把数据处理和处理数据的代码封装成一个单一的实体。在Java中，数据存储在字段中，通常还是私有的。如果想让类的使用者访问到数据，要提供访问器方法，一个setter，一个getter。 在Java中，字段和其访问器的组合常常被叫做属性。在Kotlin中，类声明一个属性和声明一个变量一样:使用val和var关键字。 1234class Person( val name: String var isMarried: Boolean) 当我们声明属性的时候，就声明了对应的构造器（val属性只有getter构造器，而var属性有setter和getter）。Kotlin的Person隐藏了和原始Java代码相同的实现，所以无论在Java代码中，还是Kotlin代码中，都可以用同样的方式使用这个类。 123456// javaPerson person = new Person("Bob", true);System.out.prientln(person.getName);// kotlinval person = Person("Bob", false) // 调用构造方法不需要关键字newprintln(person.name) // 直接访问属性，但调用的是getter 自定义访问器1234567class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; return height == width; &#125;&#125;// or get() = height == width]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战1 — 函数和变量]]></title>
    <url>%2F2017%2F11%2F19%2FKotlin%E5%AE%9E%E6%88%981%2F</url>
    <content type="text"><![CDATA[Kotlin实战1 — 函数和变量函数123fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; ​ 函数声明以关键字fun开始，函数名紧随其后，括号括起来参数列表，参数列表后面跟着返回类型，与参数用一个冒号隔开。 在Kotlin中，if是表达式，而不是语句。表达式：表达式由变量，操作符和方法调用组成，表达式的返回值类型由表达式中的元素（如操作符，变量等）决定如：a = 1。语句：是完整的执行单元，如：赋值表达式、所有使用 ++ 或者 --的变量、方法引用、创建对象的表达式，如：a++; 表达式函数体1fun max(a: Int, b: Int): Int = if(a &gt; b) a els b 如果函数体写在花括号中，我们说这个函数有代码块体，如果直接返回了一个表达式，它就有表达式体。对于表达式函数体来说，函数还可以省略返回值类型，编译器会分析作为函数体的表达式，并把它的类型作为函数的返回值类型，这种分析被称为类型推导。 变量在Kotlin中，声明变量以关键字开始，然后是变量名，最后可以加上类型（也可以不加上）。 12val question = "the ultimate question of life,th universe,and everything"val answer = 42 如果变量没有初始化器，就需要显示的指定它的类型 12val answer: Intanswer = 42 可变变量和不可变变量 val — 不可变引用。使用val声明的变量不能在初始化之后再次赋值，它对应的是Java的final变量。 var — 可变引用。这种变量的值可以被改变，对应普通（非final）的Java变量 val引用自身是不可变的，但它指向的对象可能是可变的。例如： 12val languages = arrayListOf("Java")languages.add("Android") 字符串模板1234fun main(args: Array&lt;String&gt;) &#123; val name = if(args.size &gt; 0) args[0] : "Kotlin" println("hello, $name!")&#125; Kotlin可以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。等价于Java中的字符串连接(“hello, “ + name + “!”)。还可以使用更复杂的表达式： 12345fun main(args: Array&lt;String&gt;) &#123; if(args.size &gt; 0) &#123; printl("hello, $&#123;args[0]&#125;!") &#125;&#125; 还可以在双引号中直接嵌套双引号，只要它们处于某个表达式的范围内（即花括号内）。 123fun main(args: Array&lt;String&gt;) &#123; println("hello, $&#123;if (args.size &gt; 0) args[0] else "someone"&#125;!")&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
